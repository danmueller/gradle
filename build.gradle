import java.text.DateFormat
import java.text.SimpleDateFormat
import java.util.jar.Attributes
import org.apache.tools.ant.taskdefs.condition.Os
import org.gradle.api.Task
import org.gradle.api.artifacts.repositories.WebdavResolver
import org.gradle.api.tasks.testing.ForkMode
import org.gradle.api.tasks.wrapper.Wrapper
import org.gradle.build.release.Svn
import org.gradle.build.release.Version
import org.gradle.build.samples.WrapperProjectCreator
import org.gradle.build.startscripts.StartScriptsGenerator
import org.gradle.util.GradleVersion
import org.apache.ivy.plugins.resolver.*
import org.gradle.build.docs.UserGuideTransformTask
import org.gradle.build.docs.ExtractSnippetsTask

/**
 * For building Gradle you usually don't need to specify any properties. Only certain functionality of the Gradle requires
 * setting certain properties. Those properties can be set in the gradle.properties file in the the gradle user home. The
 * following properties can be set:
 *
 * Uploading distributions to Gradle's release and snapshot repository at codehaus: codehausUserName, codehausUserPassword
 * Uploading the userguide and the javadoc to Gradle's website: websiteFtpUserName, websiteFtpUserPassword
 * Using the build to create a new distribution and install it on the local machine: gradle_installPath
 * Creating a JDK-1.4 compatible distribtution with retro-translator: gradle_retroLibsDir (This dir shoud contain rt.jar, jce.jar and jsse.jar from
 * a JDK 1.4).
 */

defaultTasks "clean", "dists"

usePlugin('groovy')

archivesBaseName = 'gradle'

sourceCompatibility = 1.5
targetCompatibility = 1.5

svn = new Svn(project)

type = 'jar'
version = new Version(svn, project, false)
group = 'org.gradle'
buildTime = new Date()
versionModifier = null

webSrcDir = new File("$srcRoot", 'website')

repositories {
    mavenCentral()
    add(new URLResolver()) {
        name = 'sf_gradleRepo'
        addArtifactPattern('http://gradle.sourceforge.net/gradleRepo/[organisation]/[module](/[branch])/[type]s/[artifact]-[revision](-[classifier])(.[ext])')
    }
}

configurations {
    distLib {
        visible = false
        extendsFrom getByName('default')
    }
    ftpAntTask
    retrotranslatorAntTask
    userGuideStyleSheets
    userGuideTask
}

dependencies {

    // todo: Improve dependency handling for xUnit jars
    ftpAntTask module("org.apache.ant:ant-commons-net:1.7.0") {
        module("commons-net:commons-net:1.4.1") {
            dependencies("oro:oro:2.0.8@jar")
        }
    }

    retrotranslatorAntTask 'net.sf.retrotranslator:retrotranslator-runtime:1.2.7@jar', 'net.sf.retrotranslator:retrotranslator-transformer:1.2.7@jar',
            'backport-util-concurrent:backport-util-concurrent:3.1@jar'

    userGuideTask 'xalan:xalan:2.7.1', 'xerces:xercesImpl:2.9.1'
    userGuideTask module('xhtmlrenderer:xhtmlrenderer:R8rc1') {
        dependency 'itext:itext:2.0.8@jar'
    }

    userGuideStyleSheets 'docbook:docbook-xsl:1.74.3@zip'

    groovy module("org.codehaus.groovy:groovy-all:1.5.6") {
        module("org.apache.ant:ant:1.7.0") {
            dependencies("org.apache.ant:ant-junit:1.7.0@jar", "org.apache.ant:ant-launcher:1.7.0@jar")
        }
    }

    compile module("commons-httpclient:commons-httpclient:3.0") {
        dependencies("commons-codec:commons-codec:1.2@jar", "org.slf4j:jcl-over-slf4j:1.5.3@jar")
    }

    // Needed by the eclipse plugin
    compile module("dom4j:dom4j:1.6.1") {
        dependencies("jaxen:jaxen:1.1@jar")
    }

    compile "org.mortbay.jetty:jetty-plus:6.1.14@jar",
            "org.mortbay.jetty:jetty-util:6.1.14@jar",
            "javax.servlet:servlet-api:2.5@jar"

    compile module("org.mortbay.jetty:jetty:6.1.14") {
        // todo - these should be runtime dependencies
        dependencies("javax.servlet:servlet-api:2.5@jar",
                "org.apache.ant:ant:1.7.0@jar",
                // todo jsp stuff should be a module
                "org.mortbay.jetty:jsp-api-2.1:6.1.14@jar",
                "org.mortbay.jetty:jsp-2.1:6.1.14@jar",
                "org.eclipse.jdt:core:3.1.1@jar",
                "org.mortbay.jetty:jetty-util:6.1.14@jar",
                "org.mortbay.jetty:jetty-naming:6.1.14@jar",
                "org.mortbay.jetty:jetty-annotations:6.1.14@jar")
    }

    compile module("org.apache.ivy:ivy:2.1.0-rc1") {
        dependencies("jsch:jsch:0.1.31")
    }
    
    compile "net.sf.jopt-simple:jopt-simple:2.4.1@jar",
            "org.apache.ant:ant:1.7.0@jar",
            "ch.qos.logback:logback-classic:0.9.9@jar",
            "org.slf4j:slf4j-api:1.5.3@jar",
            "ch.qos.logback:logback-core:0.9.9@jar",
            "commons-io:commons-io:1.4@jar",
            "commons-lang:commons-lang:2.3@jar",
            "commons-codec:commons-codec:1.2@jar",
            "slide:webdavlib:2.0@jar",
            "biz.aQute:bndlib:0.0.255@jar",
            "org.apache.maven:maven-ant-tasks:2.0.9@jar",
            "asm:asm-all:2.2@jar"

    runtime "org.apache.ant:ant-junit:1.7.0@jar",
            "org.apache.ant:ant-launcher:1.7.0@jar",
            "org.apache.ant:ant-nodeps:1.7.0@jar",
            "org.apache.ant:ant-trax:1.7.0@jar",
            "junit:junit:4.5"

    def FIRST_LEVEL_JMOCK = ['org.hamcrest:hamcrest-core:1.1@jar', 'org.hamcrest:hamcrest-library:1.1@jar', 'org.jmock:jmock-junit4:2.4.0@jar']
    testCompile "junit:junit:4.5", "xmlunit:xmlunit:1.2", FIRST_LEVEL_JMOCK
    testCompile module("org.jmock:jmock:2.4.0") {
        dependencies('org.jmock:jmock-legacy:2.4.0@jar', 'org.objenesis:objenesis:1.0', 'cglib:cglib-nodep:2.1_3')
        dependencies(FIRST_LEVEL_JMOCK as Object[])
    }
    distLib "junit:junit:4.5"
}

distributionUploadUrl = null
docsRemoteDir = ''
javadocRemoteDir = ''
groovydocRemoteDir = ''
build.taskGraph.whenReady {graph ->
    String prefix = ''
    if (graph.hasTask(':release')) {
        versionModifier = ''
        distributionUploadUrl = 'https://dav.codehaus.org/dist/gradle'
        prefix = version as String
    } else {
        versionModifier = new SimpleDateFormat('yyyyMMddHHmmssZ').format(buildTime)
        distributionUploadUrl = 'https://dav.codehaus.org/snapshots.dist/gradle'
        prefix = 'latest'
    }
    docsRemoteDir = prefix + '/docs'
    javadocRemoteDir = docsRemoteDir + '/javadoc'
    groovydocRemoteDir = docsRemoteDir + '/groovydoc'
    manifest.mainAttributes([
            (Attributes.Name.IMPLEMENTATION_TITLE.toString()): 'Gradle',
            (Attributes.Name.IMPLEMENTATION_VERSION.toString()): version.toString(),
    ])
}

processResources.doLast {
    logger.info('Write version properties')
    Properties versionProperties = new Properties()
    versionProperties.putAll([
            (GradleVersion.VERSION): version.toString(),
            (GradleVersion.BUILD_TIME): DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(buildTime)
    ])
    versionProperties.store(new FileOutputStream(new File(classesDir, GradleVersion.FILE_NAME)), '')
}

[compile, compileTests]*.groovyOptions*.fork(memoryInitialSize: '128M', memoryMaximumSize: '1G')

test {
    // We set forkmode to ONCE as our tests are written in Groovy and the startup time of Groovy is significant.
    options.fork(forkMode: ForkMode.ONCE, jvmArgs: ["-ea", '-Xms128m', '-Xmx1g', '-XX:MaxPermSize=128m', '-XX:+HeapDumpOnOutOfMemoryError'])

    exclude 'org/gradle/integtests/**/*IntegrationTest.*'
}

task wrapperJar(type: Jar) {
    appendix = 'wrapper'
    fileSet(dir: classesDir) {
        include 'org/gradle/wrapper/'
    }
    manifest.mainAttributes("Main-Class": 'org.gradle.wrapper.WrapperMain')
}

jar.manifest.mainAttributes("Main-Class": "org.gradle.BootstrapMain")

explodedDistDir = new File(distsDir, 'exploded')
explodedDistDocsDir = new File(explodedDistDir, 'docs')
explodedDistJavadocsDir = new File(explodedDistDocsDir, 'javadoc')
explodedDistGroovydocsDir = new File(explodedDistDocsDir, 'groovydoc')
explodedDistSamplesDir = new File(explodedDistDir, 'samples')
explodedDistLibDir = new File(explodedDistDir, 'lib')
samplesSrcDir = new File(srcRoot, 'samples')
userguideOutputDir = new File(samplesSrcDir, 'userguideOutput')

task explodedDistBase(dependsOn: [libs, javadoc, groovydoc]) << {
    [explodedDistDir, explodedDistSamplesDir, explodedDistLibDir]*.mkdirs()
    File explodedDistBinDir = mkdir(explodedDistDir, 'bin')
    File explodedDistSrcDir = mkdir(explodedDistDir, 'src')

    ant {
        logger.info('Generate lib dir')
        configurations.distLib.each {File file ->
            copy(file: file, todir: explodedDistLibDir)
        }
        // todo: find out why Ivy does not include the jar in the resolve
        delete { fileset(dir:explodedDistLibDir, includes:"$archivesBaseName-*.jar") }
        copy(file: jar.archivePath, toDir: explodedDistLibDir)
        copy(file: wrapperJar.archivePath, toDir: explodedDistLibDir)
        logger.info('Generate start scripts')
        StartScriptsGenerator.generate("$archivesBaseName-${version}.jar", explodedDistBinDir, archivesBaseName)
        logger.info('Generate and copy samples.')
        WrapperProjectCreator.createProject(explodedDistSamplesDir, binZip.archivePath.parentFile,
                version.toString())
        logger.info('Copy binary sources.')
        copy(toDir: explodedDistSrcDir) {
            (srcDirs + resourceDirs + groovySrcDirs).findAll {it.isDirectory()}.each {dir -> fileset(dir: dir)}
        }
        logger.info('Copy and generate top level files.')
        copy(toDir: explodedDistDir) {fileset(dir: new File(srcRoot, 'toplevel'))}
        // Set permissions (important for running integration tests against the exploded dist)
        chmod(dir: "$explodedDistDir/bin", perm: "ugo+rx", includes: "**/*")
    }
}

task explodedDist(dependsOn: [explodedDistBase, 'userguide', 'distDocs'])

zipRootFolder = "$archivesBaseName-${-> version}"

distsRetroLibsFolder = new File(distsDir, 'retroLibs')

task retroTranslateLibs(dependsOn: explodedDist) << {
    distsRetroLibsFolder.mkdirs()
    ant {
        taskdef(name: "retrotranslator", classname: "net.sf.retrotranslator.transformer.RetrotranslatorTask",
                classpath: configurations.retrotranslatorAntTask.asPath)
        List libFiles = explodedDistLibDir.listFiles()
        File logbackCore = libFiles.find { it.name.startsWith('logback-core') }
        File logbackClassic = libFiles.find { it.name.startsWith('logback-classic') }
        File gradle = libFiles.find { it.name.startsWith('gradle-') && !it.name.startsWith('gradle-wrapper') }
        File gradleWrapper = libFiles.find { it.name.startsWith('gradle-wrapper')}
        List retroFiles = [logbackCore, logbackClassic, gradle, gradleWrapper]
        String libExcludes = retroFiles.join(',')
        retroFiles.each {File file ->
            retroExe(file) {
                fileset(dir: distsRetroLibsFolder)
                fileset(dir: explodedDistLibDir, excludes: libExcludes)
                fileset(dir: gradle_retroLibsDir)
            }
        }
    }
}
retroTranslateLibs {
    enabled = project.hasProperty('gradle_retroLibsDir')
    skipProperties << 'skip.archive_all-jdk14_zip'
}

void retroExe(File file, Closure fileSet) {
    ant {
        retrotranslator(target: "1.4", destjar: new File(distsRetroLibsFolder, file.name), smart: true, verify: false, failonwarning: false) {
            jarfileset(dir: explodedDistLibDir, includes: file.name)
            classpath() {
                fileset(dir: gradle_retroLibsDir)
                fileSet.delegate = delegate
                fileSet()
            }
        }
    }
}

Closure binFileSets = {task ->
    delegate = task
    zipFileSet(dir: explodedDistDir, prefix: zipRootFolder, fileMode: '775') {
        include 'bin/*'
        exclude 'bin/*.*'
    }
    zipFileSet(dir: explodedDistDir, prefix: zipRootFolder) {
        include 'bin/*.*'
    }
}

task allZip(type: Zip) {
    dependsOn explodedDist
    classifier = 'all'
}
allZip.doFirst {task ->
    task.configure {
        zipFileSet(dir: explodedDistDir, prefix: zipRootFolder) {
            exclude 'bin/*'
        }
        binFileSets(delegate)
    }
}

task binZip(type: Zip) {
    dependsOn explodedDist
    classifier = 'bin'
}
binZip.doFirst {task ->
    task.configure {
        zipFileSet(dir: explodedDistDir, prefix: zipRootFolder) {
            exclude 'bin/*'
            exclude 'src/'
            exclude 'samples/'
        }
        binFileSets(delegate)
    }
}

task srcZip(type: Zip) {
    dependsOn explodedDist
    classifier = 'src'
}
srcZip.doFirst {task ->
    task.configure {
        zipFileSet(dir: projectDir, prefix: zipRootFolder, fileMode: '775') {
            include 'gradlew'
        }
        zipFileSet(dir: projectDir, prefix: zipRootFolder) {
            include 'buildSrc/', 'wrapper/', 'lib/', 'src/', 'gradle.properties', 'build.gradle', 'gradlew.bat'
        }
    }
}

task jdk14AllZip(type: Zip) {
    dependsOn retroTranslateLibs, explodedDist
    classifier = 'all-jdk14'
    enabled = project.hasProperty('gradle_retroLibsDir')
}
jdk14AllZip.doFirst {Task task ->
    task.configure {
        zipFileSet(dir: explodedDistDir, prefix: zipRootFolder) {
            exclude 'bin/*'
            exclude 'lib/gradle*.jar'
            exclude 'lib/logback*.jar'
        }
        zipFileSet(dir: distsRetroLibsFolder, prefix: "$zipRootFolder/lib")
        configurations.retrotranslatorAntTask.each {File file ->
            zipFileSet(dir: file.parentFile, prefix: "$zipRootFolder/lib") {
                include file.name
            }
        }
        binFileSets(delegate)
    }
}

artifacts {
    tasks.findAll {task -> task.name.matches('.*Zip') }.each {
        dists it
    }
}

groovydoc.destinationDir = explodedDistGroovydocsDir

javadoc {
    dependsOn compile
    destinationDir = explodedDistJavadocsDir
    // todo: include only the public packages
    options.subPackages 'org.gradle'
    exclude 'org.gradle.api.internal'
    // todo: make this true
    failOnError = false
}
javadoc.doFirst {
    javadoc.title = "Gradle API $version"
    javadoc.options.docTitle = javadoc.title
}

srcDocsDir = file('src/docs')
userguideDir = new File(buildDir, "$docsDir.name/userguide")
userguideSrcDir = new File(srcDocsDir, 'userguide')
userguideHtmlDir = new File(explodedDistDocsDir, 'userguide')
userguidePdfFile = new File(userguideHtmlDir, 'userguide.pdf')
userguideSingleHtmlFile = new File(userguideHtmlDir, 'userguide_single.html')
docbookSrc = new File(project.buildDir, 'docbook/src')
docbookDir = new File(project.buildDir, 'docbook/stylesheets')
snippetsDir = new File(project.buildDir, 'docbook/snippets')

task userguide(dependsOn: ['userguideHtml', 'userguideSingleHtml', 'userguidePdf'], description: 'Generates the userguide')

task samples(type: ExtractSnippetsTask) {
    sourceFiles = ant.fileset(dir: samplesSrcDir) {
        exclude(name: 'userguideOutput/**')
        exclude(name: 'userguide/tutorial/antChecksumFiles/**')
    }
    destDir = explodedDistSamplesDir
    snippetsDir = project.snippetsDir
}
samples << {
    ant.copy(todir: explodedDistSamplesDir) {
        fileset(dir: samplesSrcDir) {
            include(name: 'userguide/tutorial/antChecksumFiles/**')
        }
    }
}

task userguideSrc(type: UserGuideTransformTask, dependsOn: samples) {
    sourceFile = new File(userguideSrcDir, 'userguide.xml')
    destFile = new File(docbookSrc, 'userguide.xml')
    snippetsDir = project.snippetsDir
    classpath = configurations.userGuideTask
}
userguideSrc.doFirst {
    userguideSrc.javadocUrl = "http://www.gradle.org/${javadocRemoteDir}"
    userguideSrc.groovydocUrl = "http://www.gradle.org/${groovydocRemoteDir}"
}
userguideSrc.skipProperties << 'skip.userguide'

task userguideStyleSheets << {
    ant.unzip(src: configurations.userGuideStyleSheets.singleFile, dest: docbookDir) {
        globmapper(from: 'docbook-xsl-1.74.3/*', to: '*')
    }
    ant.copy(todir: docbookDir) {
        fileset(dir: new File(srcDocsDir, 'stylesheets'), includes: '*.xsl')
    }
}
userguideStyleSheets.skipProperties << 'skip.userguide'

task userguideHtml(dependsOn: [userguideSrc, userguideStyleSheets]) << {
    ant.java(classname: 'org.apache.xalan.xslt.Process', failonerror: true) {
        arg(value: '-in')
        arg(value: new File(docbookSrc, 'userguide.xml'))
        arg(value: '-xsl')
        arg(value: new File(docbookDir, 'userGuideHtml.xsl'))
        arg(line: "-param base.dir ${userguideHtmlDir}/")
        classpath {
            path(path: configurations.userGuideTask.asPath)
            path(location: new File(docbookDir, 'extensions/xalan27.jar'))
        }
    }
    ant.copy(file: new File(userguideSrcDir, 'style.css'), todir: userguideHtmlDir)
}
userguideHtml.skipProperties << 'skip.userguide'

task userguideSingleHtml(dependsOn: [userguideSrc, userguideStyleSheets]) << {
    userguideSingleHtmlFile.parentFile.mkdirs()
    
    ant.java(classname: 'org.apache.xalan.xslt.Process', failonerror: true) {
        arg(value: '-in')
        arg(value: new File(docbookSrc, 'userguide.xml'))
        arg(value: '-out')
        arg(value: userguideSingleHtmlFile)
        arg(value: '-xsl')
        arg(value: new File(docbookDir, 'userGuideSingleHtml.xsl'))
        classpath {
            path(path: configurations.userGuideTask.asPath)
            path(location: new File(docbookDir, 'extensions/xalan27.jar'))
        }
    }
    ant.copy(file: new File(userguideSrcDir, 'style.css'), todir: userguideSingleHtmlFile.parentFile)
    ant.copy(file: new File(userguideSrcDir, 'print.css'), todir: userguideSingleHtmlFile.parentFile)
}
userguideSingleHtml.skipProperties << 'skip.userguide'

task userguidePdf(dependsOn: [userguideSrc, userguideStyleSheets]) << {
    File pdfSourceHtml = new File(docbookSrc, 'userguidePdf.html')

    pdfSourceHtml.parentFile.mkdirs()
    userguidePdfFile.parentFile.mkdirs()

    ant.java(classname: 'org.apache.xalan.xslt.Process', failonerror: true) {
        arg(value: '-in')
        arg(value: new File(docbookSrc, 'userguide.xml'))
        arg(value: '-out')
        arg(value: pdfSourceHtml)
        arg(value: '-xsl')
        arg(value: new File(docbookDir, 'userGuidePdf.xsl'))
        classpath {
            path(path: configurations.userGuideTask.asPath)
            path(location: new File(docbookDir, 'extensions/xalan27.jar'))
        }
    }
    ant.copy(file: new File(userguideSrcDir, 'style.css'), todir: pdfSourceHtml.parentFile)
    ant.copy(file: new File(userguideSrcDir, 'print.css'), todir: pdfSourceHtml.parentFile)

    def uris = configurations.userGuideTask.files.collect {it.toURI().toURL()}
    def classloader = new URLClassLoader(uris as URL[], getClass().classLoader)
    def renderer = classloader.loadClass('org.xhtmlrenderer.pdf.ITextRenderer').newInstance()
    renderer.setDocument(pdfSourceHtml)
    renderer.layout()

    userguidePdfFile.withOutputStream {
        renderer.createPDF(it)
    }
}
userguidePdf.skipProperties << 'skip.userguide'

task uploadDocs(dependsOn: [userguide, javadoc, groovydoc]) << {
    ftp(action: 'mkdir', remotedir: docsRemoteDir)
    ftp(action: 'delete', remotedir: docsRemoteDir) {
        fileset() {
            include(name: '**/*')
        }
    }
    ftp(action: 'send', remotedir: docsRemoteDir) {
        fileset(dir: explodedDistDocsDir)
    }
}

task distDocs(type: UserGuideTransformTask, dependsOn: userguideStyleSheets) {
    standalone = true
    sourceFile = new File(userguideSrcDir, 'gettingStarted.xml')
    destFile = new File(docbookSrc, 'gettingStarted.xml')
    snippetsDir = project.snippetsDir
    classpath = configurations.userGuideTask
}
distDocs.doFirst {
    distDocs.javadocUrl = "http://www.gradle.org/${javadocRemoteDir}"
    distDocs.groovydocUrl = "http://www.gradle.org/${groovydocRemoteDir}"
}
distDocs << {
    explodedDistDir.mkdirs()

    ant.copy(file: new File(userguideSrcDir, 'style.css'), todir: docbookDir)
    ant.java(classname: 'org.apache.xalan.xslt.Process', failonerror: true) {
        arg(value: '-in')
        arg(value: new File(docbookSrc , 'gettingStarted.xml'))
        arg(value: '-out')
        arg(value: new File(explodedDistDir, 'getting-started.html'))
        arg(value: '-xsl')
        arg(value: new File(docbookDir, 'standaloneHtml.xsl'))
        classpath {
            path(path: configurations.userGuideTask.asPath)
            path(location: new File(docbookDir, 'extensions/xalan27.jar'))
        }
    }
}

task websiteDocs(type: UserGuideTransformTask, dependsOn: userguideStyleSheets) {
    standalone = true
    sourceFile = new File(userguideSrcDir, 'gettingStarted.xml')
    destFile = new File(docbookSrc, 'gettingStarted.xml')
    snippetsDir = project.snippetsDir
    classpath = configurations.userGuideTask
}
websiteDocs.doFirst {
    websiteDocs.javadocUrl = "http://www.gradle.org/${javadocRemoteDir}"
    websiteDocs.groovydocUrl = "http://www.gradle.org/${groovydocRemoteDir}"
}
websiteDocs << {
    File websiteDocs = new File(buildDir, 'docs')
    websiteDocs.mkdirs()

    ant.java(classname: 'org.apache.xalan.xslt.Process', failonerror: true) {
        arg(value: '-in')
        arg(value: new File(docbookSrc , 'gettingStarted.xml'))
        arg(value: '-out')
        arg(value: new File(websiteDocs, 'getting-started.html'))
        arg(value: '-xsl')
        arg(value: new File(docbookDir, 'docFragment.xsl'))
        classpath {
            path(path: configurations.userGuideTask.asPath)
            path(location: new File(docbookDir, 'extensions/xalan27.jar'))
        }
    }
}

// The integtests depend on dists because of the wrapper test, and userguideSrc because of the int test generated from
// the userguide source
integTestDistDir = new File(buildDir, 'integ test')
task integTest(type: Test, dependsOn: [explodedDist, binZip, userguideSrc]) {
    options.fork(forkMode: ForkMode.ONCE, jvmArgs: ["-ea"])
    options.systemProperties['integTest.gradleHomeDir'] = integTestDistDir.absolutePath
    options.systemProperties['integTest.srcDir'] = file('src').absolutePath
    options.systemProperties['integTest.userGuideInfoDir'] = docbookSrc.absolutePath

    include 'org/gradle/integtests/**/*IntegrationTest.*'
    exclude '**/Abstract*'
}
integTest.doFirst {
    ant {
        copy(todir: integTestDistDir) {
            fileset(dir: explodedDistDir )
        }
        chmod(dir: "$integTestDistDir/bin", perm: "ugo+rx", includes: "**/*")
    }
}

task nightlyBuild(dependsOn: [integTest, uploadDocs])

task install(dependsOn: integTest, description: 'Installs the distribution into directory $gradle_installPath') << {
    ant.delete(dir: installDir)
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        windowsInstall()
    } else {
        asternixInstall()
    }
    ant.move(file: "${installDir.parentFile}/$zipRootFolder", tofile: installDir)
}

build.taskGraph.whenReady { graph ->
    if (graph.hasTask(install)) {
        // Do this early to ensure that the properties we need have been set, and fail early
        installDir = file("$gradle_installPath")
        if (installDir.file) {
            throw new RuntimeException("Install directory $installDir does not look like a Gradle installation. Cannot delete it to install.")
        }
        if (installDir.directory) {
            File libDir = new File(installDir, "lib")
            if (!libDir.directory || !libDir.list().findAll { it.matches('gradle.*\\.jar')}) {
                throw new RuntimeException("Install directory $installDir does not look like a Gradle installation. Cannot delete it to install.")
            }
        }
    }
}

void windowsInstall() {
    ant.unzip(src: binZip.archivePath, dest: installDir.parentFile)
}

/**
 * We can't use the Ant unzip task, as this task does not preserve the *nix file system permissions of the Gradle zip.
 */
void asternixInstall() {
    ant.exec(executable: "unzip") {
        arg(value: '-q')
        arg(value: '-d')
        arg(value: installDir.parentFile)
        arg(value: "${binZip.archivePath}")
    }
}

uploadDists {
    dependsOn 'integTest'
}.doFirst {
    it.repositories.add(new WebdavResolver()) {
        name = 'gradleReleases'
        user = codehausUserName
        userPassword = codehausUserPassword
        addArtifactPattern("$distributionUploadUrl/[artifact]-[revision](-[classifier]).[ext]" as String)
    }
}

task developerBuild(dependsOn: [clean, integTest])

task ide << {
    def libDir = file('lib')
    ant.delete(dir: libDir)
    [configurations.runtime, configurations.testRuntime].each {config ->
        config.files.each {file ->
            ant.copy(file: file, todir: libDir)
        }
    }
}

task release(dependsOn: [uploadDists, uploadDocs]) << {
    svn.release()
}

task wrapper(type: Wrapper, dependsOn: binZip) << {task ->
    task.configure {
        gradleVersion = customWrapperVersion ?: version
        jarPath = 'wrapper'
    }
}

task rebuildWrapper(dependsOn: [clean, wrapper])

void ftp(Map args, Closure antFileset = {}) {
    ant {
        taskdef(name: 'ftp',
                classname: 'org.apache.tools.ant.taskdefs.optional.net.FTP',
                classpath: configurations.ftpAntTask.asPath)
        Map ftpArgs = args + [
                server: 'ftp.gradle.org',
                userid: websiteFtpUserName,
                password: websiteFtpUserPassword
        ]
        delegate.ftp(ftpArgs) {
            antFileset.delegate = delegate
            antFileset()
        }
    }
}
