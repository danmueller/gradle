<chapter id='dependency_management' xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>Dependency Management</title>
    <section id='sec:Introduction'>
        <title>Introduction</title>
        <para>The current dependency management solutions all require to work with XML descriptor files and are usually
            based on remote repositories for downloading the dependencies. Gradle fully supports this approach. Gradle
            works
            <emphasis>perfectly</emphasis>
            with your existent dependency management infrastructure, be it Maven or Ivy. All the repositories you have
            set up with your custom pom or ivy files can be used as they are. No changes necessary. But Gradle offers
            also a simpler approach which might be better suited for many projects.
        </para>
        <para>We think dependency management is very important for almost any project. Yet the kind of dependency
            management you need depends on the complexity and the environment of your project. Is your project a
            distribution or a library? Is it part of an enterprise environment, where it is integrated into other
            projects builds or not? But all types of projects share the following requirements:
        </para>
        <itemizedlist>
            <listitem>
                <para>The version of the jar must be easy to recognize. Sometimes the version is in the Manifest file of
                    the jar, often not. And even if, it is rather painful to always look into the Manifest file to learn
                    about the version. Therefore we think that you should only use jars which have there version as part
                    of there file name.
                </para>
            </listitem>
            <listitem>
                <para>It has to be clear what are the first level dependencies and what are the transitive ones. There
                    are different ways to achieve this. We will look at this later.
                </para>
            </listitem>
            <listitem>
                <para>Conflicting versions of the same jar should be detected and either resolved or cause an exception.
                </para>
            </listitem>
        </itemizedlist>
        <section id='sub:versioning_the_jar_name'>
            <title>Versioning the jar name</title>
            <para>Why do we think this is necessary? Without a dependency management as described above, your are likely
                to burn your fingers sooner or later. If it is unclear which version of a jar your are using, this can
                introduce subtle bugs which are very hard to find. For example there might be a project which uses
                Hibernate 3.0.4. There are some problems with Hibernate so a developer installs version 3.0.5 of
                Hibernate on her machine. This did not solve the problem but she forgot to roll back Hibernate to 3.0.4.
                Weeks later there is an exception on the integration machine which can't be reproduced on the developer
                machine. Without a version in the jar name this problem might take a long time to debug. Version in the
                jar names increases the expressiveness of your project and making it easier to maintain.
            </para>
        </section>
        <section id='sub:transitive_dependency_management'>
            <title>Transitive dependency management</title>
            <para>Why is transitive dependency management so important? If you don't know which dependencies are first
                level dependencies and which ones are transitive you are loosing very soon control over your build. Even
                Gradle has already 20+ jars. An enterprise project using Spring, Hibernate, etc. easily ends up with
                100+ jars. There is no way to memorize where all this jars belong to. If you want to get rid of a first
                level dependency you can't be sure which other jars you should remove. Because a dependency of your
                first level dependency might also be a first level dependency itself. Or it might be a transitive
                dependency of another of your first level dependency. Many first level dependencies are runtime
                dependencies and the transitive dependencies are of course all runtime dependencies. So the compiler
                won't help you much here. The end of the story is, as we have seen very often, nobody dares to remove
                any jar any longer. The project classpath is a complete mess and if a classpath problems arises, hell on
                earth invites you for a ride. In one of my former projects, I've found some ldap related jar in the
                classpath, which sheer presence, as I've found out after much research, accelerated LDAP access. So
                removing this jar would not have led to any errors at compile or runtime.
            </para>
            <para>Gradle offers you different ways to express what are first level and what are transitive dependencies.
                Gradle allows you for example to store your jars in CVS or SVN without XML descriptor files and still
                use transitive dependency management. Gradle also validates your dependency hierarchy against the
                reality of your code by using only the first level dependencies for compiling.
            </para>
        </section>
        <section id='sub:version_conflicts'>
            <title>Version conflicts</title>
            <para>In your dependency description you tell Gradle which version of a dependency is needed by another
                dependency. This leads frequently to conflicts. Different dependencies rely on different versions of
                another dependency. The JVM unfortunately does not offer yet any easy way, to have different versions of
                the same jar in the classpath (See <xref linkend='sub:dependency_management_and_java'/>). What Gradle
                offers you is a resolution strategy, by default the newest version is used. To deal with problems due to
                version conflicts, reports with dependency graphs are also very helpful. Such reports are another
                feature of dependency management.
            </para>
        </section>
        <section id='sub:dependency_management_and_java'>
            <title>Dependency management and Java</title>
            <para>Traditionally, Java has offered no support at all for dealing with libraries and versions. There are
                no standard ways to say that
                <literal>foo-1.0.jar</literal>
                depends on a <literal>bar-2.0.jar</literal>. This has led to proprietary solutions. The most popular ones
                are Maven and Ivy. Maven is a complete build system whereas Ivy focuses solely on dependency management.
            </para>
            <para>Both approaches rely on descriptor xml files, which contains information about the dependencies of a
                particular jar. Both also use repositories where the actual jars are placed together with there
                descriptor files. And both offer resolution for conflicting jar versions in one form or the other. Yet
                we think the differences of both approaches are
                <emphasis>gigantic</emphasis>
                in terms of flexibility and maintainability. Beside this, Ivy fully supports the Maven dependency
                handling. So with Ivy you have access to both worlds. We like Ivy very much. Gradle uses it under the
                hood for its dependency management. Ivy is most often used via Ant and XML descriptors. But it also has
                a very good API. We integrate deeply with Ivy via its API. This enables us to build new concepts on top
                of Ivy which Ivy does not offer itself.
            </para>
            <para>Right now there is a lot of movement in the field of dependency handling. There is OSGi and there is
                JSR-277. OSGi is available already, JSR-277 is supposed to be shipped with Java 7. These technologies
                deal also with a painful problem which is neither solved by Maven nor by Ivy. This is enabling different
                versions of the same jar to be used at runtime.
            </para>
        </section>
    </section>
    <section id='sec:how_to_declare_your_dependencies'>
        <title>How to declare your dependencies</title>
        <para>People who know Ivy have come across most the concepts we are going to introduce now. But Gradle does not
            use any XML for declaring the dependencies (e.g. no
            <literal>ivy.xml</literal>
            file). It has its own notations which is part of the Gradle build file.
        </para>
        <section id='sub:configurations'>
            <title>Configurations</title>
            <para>Dependencies are grouped in configurations. Configurations have a name, a number of other properties,
                and they can extend each other. For examples see: <xref linkend='sec:artifact_configurations'/>
                If you use the Java or Groovy plugin, Gradle adds a number of pre-defined configurations to your build. The
                plugin also assigns configurations to tasks. See
                <xref linkend='sec:java_plugin_and_dependency_management'/>
                for details. Of course you can add your add custom configurations on top of that. There are many use cases
                for custom configurations.This is very handy for
                example for adding dependencies not needed for building or testing your software (e.g. additional JDBC
                drivers to be shipped with your distribution). The configurations are managed by a
                <emphasis>configurations</emphasis> object. The closure you pass to the configurations object is applied
                against its api. To learn more about this API have a look at the javadoc:
                <apilink class='org.gradle.api.artifacts.dsl.ConfigurationHandler'/>. 
            </para>
        </section>
        <section id='sub:module_dependencies'>
            <title>Module Dependencies</title>
            <para>Module dependencies are the most common dependencies. They correspond to a dependency in an external
                repository.
            </para>
            <sample id="moduleDependencies" dir="userguide/artifacts/externalDependencies">
                <sourcefile file="build.gradle" snippet="module-dependencies"/>
            </sample>
            <para>Gradle provides different notations for module dependencies. There is a String notation and
                a map notation. A module dependency has an API which allows for further configuration. Have a look at
                <apilink class='org.gradle.api.artifacts.ModuleDependency'/> to learn all about the API.
                This API provides properties and configuration methods. Via the string notation you can define a subset
                the properties. With the map notation you can define all properties. To have access to the complete API,
                either with the map or with the string notation, you can assign a single dependency to a configuration
                together with a closure.
            </para>
            <para>If you declare a module dependency, Gradle looks for a corresponding module descriptor file (pom.xml or
                ivy.xml) in the repositories. If such a module descriptor file exists, it is parsed and the artifacts of
                this module (e.g. hibernate-3.0.5.jar) as well as its dependencies (e.g. cglib) are downloaded. If no such
                module descriptor file exists, Gradle looks for a file called hibernate-3.0.5.jar to retrieve. In Maven
                a module can only have one and only one artifact. In Gradle and Ivy a module can have multiple artifacts.
                Each artifact can have a different set of dependencies.
            </para>
            <section id='ssub:artifact_dependencies'>
                <title>Artifact only notation</title>
                <para>As said above, the Gradle default behavior if no module descriptor file can be found is to
                    download a jar with the name of the module. But sometimes you want to download only the artifact jar, without
                    the dependencies, despite that the repository contains module descriptors.
                    <footnote>
                        <para>Gradle supports partial multiproject builds (see<xref linkend='multi_project_builds'/>).
                        </para>
                    </footnote>
                    And sometimes you want to download a zip from a repository, that does not have module descriptors.
                    Gradle provides an <emphasis>artifact only</emphasis> notation for those use cases:
                    <sample id="artifactOnly" dir="userguide/artifacts/externalDependencies">
                        <sourcefile file="build.gradle" snippet="artifact-only"/>
                    </sample>
                    An artifact only notation creates a module dependency which downloads only the artifact file with
                    the specified extension. Existing module descriptors are ignored.
                </para>
            </section>
            <section id='ssub:classifiers'>
                <title>Classifiers</title>
                <para>The Maven dependency management has the notion of classifiers.
                    <footnote>
                        <para>
                            <ulink url='http://www.sonatype.com/books/maven-book/reference/pom-relationships-sect-project-relationships.html'/>
                        </para>
                    </footnote>
                    Gradle supports this. To retrieve classified dependencies from a maven repository you can write:
                    <sample id="classifier" dir="userguide/artifacts/excludesAndClassifiers">
                        <sourcefile file="build.gradle" snippet="classifier"/>
                    </sample>
                </para>
            </section>
        </section>
        <section id='sub:client_module_dependencies'>
            <title>Client Module Dependencies</title>
            <para>Client module dependencies enable you to declare
                <emphasis>transitive</emphasis>
                dependencies directly in your build script. They are a replacement for a module descriptor xml file in
                an external repository.
            </para>
            <sample id="client-modules" dir="userguide/artifacts/externalDependencies">
                <sourcefile file="build.gradle" snippet="client-modules"/>
            </sample>
            <para>This declares a dependency of your project on Groovy. Groovy itself has dependencies. But Gradle does
                not look for an xml descriptor to figure them out but gets the information from the build file. The
                dependencies of a client module can be normal module dependencies or artifact dependencies or another
                client module. Have also a look at the javadoc: <apilink class='org.gradle.api.artifacts.ClientModule'/>
            </para>
            <para>In the current release
                <emphasis>Client Modules</emphasis>
                have one limitation. Let's say your project is a library and you want this library to be uploaded
                to your company's Maven or Ivy repository. Gradle uploads the jars of your project to the company
                repository together with the XML descriptor file of the dependencies. If you use
                <literal>Client Modules</literal>
                the dependency declaration in the XML descriptor file is not correct. We try to improve this in a future
                release of Gradle.
            </para>
        </section>
        <section id='sub:project_dependencies'>
            <title>Project dependencies</title>
            <para>Gradle distinguishes between external dependencies and dependencies on projects which are part of the
                same multi-project build. For the latter you can declare <emphasis>Project Dependencies</emphasis>.
            </para>
            <sample id="project-dependencies" dir="java/multiproject/api">
                <sourcefile file="build.gradle" snippet="project-dependencies"/>
            </sample>
            <para>Have also a look at the javadoc: <apilink class="org.gradle.api.artifacts.ProjectDependency"/>
            </para>
            <para>Multi-project builds are discussed in <xref linkend='multi_project_builds'/>.
            </para>
        </section>
        <section id='sub:exclude_transitive_dependencies'>
            <title>Excluding transitive dependencies</title>
            <para>You can exclude a <emphasis>transitive</emphasis> dependency either by configuration of by dependency:
            </para>
            <sample id="exclude-dependencies" dir="userguide/artifacts/excludesAndClassifiers">
                <sourcefile file="build.gradle" snippet="exclude-dependencies"/>
            </sample>
            <para>The <emphasis>junit</emphasis> dependency will only be excluded from
                <emphasis>groovy</emphasis>. If another dependency has a transitive dependency on
                <emphasis>junit</emphasis>, the latter will make it into your classpath. If you define
                an exclude for a particular configuration, the excluded transitive dependency will be filtered for all
                dependencies when resolving this configuration or any inheriting configuration.
                If you want to exclude a transitive dependency from all your
                configurations you can use the Groovy spread-dot operator to express this in a concise way, as shown in the example. 
                When defining an exclude, you can
                specify either only the organization or only the module name or both.
                Have also a look at the javadoc of <apilink class="org.gradle.api.artifacts.Dependency"/> and
                <apilink class="org.gradle.api.artifacts.Configuration"/>.
            </para>
        </section>
        <section>
            <title>Working with the Dependencies</title>
            <para>To assign dependencies to configurations, you can pass a closure to the <emphasis>dependencies</emphasis>
                object. To work with the dependencies assigned to a configuration, you can use the API of the
                configuration object. See the javadoc:
                <apilink class='org.gradle.api.artifacts.Configuration'/>.
            </para>
        </section>
    </section>
    <section id='sec:java_plugin_and_dependency_management'>
        <title>Java Plugin and Dependency Management</title>
        <para>The Java Plugin preconfigures the dependency management. It adds a set of configurations and
            assign those configurations to tasks like <literal>compile</literal> and <literal>test</literal>.
            <xref linkend='tab:configurations'/>
            shows the details. 
        </para>
        <table id='tab:configurations'>
            <title>Java/Groovy Configurations</title>
            <thead>
                <tr>
                    <td>Name</td>
                    <td>Extends</td>
                    <td>Task</td>
                    <td>Meaning</td>
                </tr>
            </thead>
            <tr>
                <td>compile</td>
                <td>-</td>
                <td>compile</td>
                <td>Compile time dependencies</td>
            </tr>
            <tr>
                <td>runtime</td>
                <td>compile</td>
                <td>-</td>
                <td>Runtime dependencies</td>
            </tr>
            <tr>
                <td>testCompile</td>
                <td>compile</td>
                <td>compileTests</td>
                <td>Additional dependencies for compiling tests.</td>
            </tr>
            <tr>
                <td>testRuntime</td>
                <td>runtime, testCompile</td>
                <td>test</td>
                <td>Additional dependencies for running tests only.</td>
            </tr>
            <tr>
                <td>master</td>
                <td>-</td>
                <td>uploadMaster</td>
                <td>Dependencies (e.g. jars) produced by this project.</td>
            </tr>
            <tr>
                <td>default</td>
                <td>runtime, master</td>
                <td>-</td>
                <td>Dependencies produced
                    <literal>and</literal>
                    required by this project.
                </td>
            </tr>
        </table>
    </section>
    <section id='sec:strategies_of_transitive_dependency_management'>
        <title>Strategies of transitive dependency management</title>
        <para>Many projects rely on the <ulink url='http://repo1.maven.org/maven2'>Maven2 repository</ulink>. This is not
            without problems.
        </para>
        <itemizedlist>
            <listitem>
                <para>The IBibilio repository is sometimes down or has a very long response time.
                </para>
            </listitem>
            <listitem>
                <para>The pom.xml's of many projects have wrong informations. (as one example, the pom of
                    commons-httpclient-3.0 declares junit as a runtime dependency).
                </para>
            </listitem>
            <listitem>
                <para>For many projects there is not one right set of dependencies (as more or less imposed by he
                    <literal>pom</literal>
                    format).
                </para>
            </listitem>
        </itemizedlist>
        <para>If your project relies on the IBibilio repository you are likely to need an additional custom repository,
            because:
        </para>
        <itemizedlist>
            <listitem>
                <para>You might need dependencies that are not uploaded to IBibilio yet.
                </para>
            </listitem>
            <listitem>
                <para>You want to deal properly with wrong metadata in a IBibilio pom.xml.
                </para>
            </listitem>
            <listitem>
                <para>You don't want to expose people who want to build your project, to the
                    downtimes or sometimes very long response times of IBibilio.
                </para>
            </listitem>
        </itemizedlist>
        <para>It is not a big deal to set-up a custom repository.
            <footnote>
                <para>If you want to shield your project from the downtimes of IBibilio things get more complicated. You
                    probably want to set-up a repository proxy for this. In an enterprise environment this is rather
                    common. For an open source project it looks like overkill.
                </para>
            </footnote>
            But it can be tedious, to keep it up to date. For a new version, you have always to create the new XML
            descriptor and the directories. And your custom repository is another infrastructure element which might
            have downtimes and needs to be updated. To enable historical builds, you need to keep all the past
            libraries. It is another layer of indirection, which contains information relevant for your build and you
            have to navigate to the lengthy path with your browser to get the information. All this is not really a big
            deal but in its sum it has an impact on your agility. Why should you cope with this? You pay
            something, so you should also get something, right? So we end up with the question: Does it make sense to
            store the dependency information (and the dependencies) in remote repositories? Our answer is: It depends.
        </para>
        <section id='sub:enterprise_environments'>
            <title>Enterprise Environments</title>
            <para>In a larger enterprise environment you are likely to have a number of independent builds, possibly
                many different, large multi-project builds. Here a repository infrastructure makes a lot of sense. You
                have already infrastructure that guarantees a high uptime. Multiple projects can share there information
                about certain common dependencies they have. There is a central place to look for dependency
                information. And the repositories are used to integrate the internal projects with each other. One
                project publishes itself to the company repository, with all its dependency information stored in an
                ivy.xml or pom.xml file.
                <footnote>
                    <para>As discussed in
                        <xref linkend='sub:other_environments'/>
                        this will be also possible with client modules in a future release.
                    </para>
                </footnote>
                Together with a continuous integration server this offers a strong integration for projects with separate
                builds. As you have seen, Gradle fully supports this approach.
            </para>
        </section>
        <section id='sub:other_environments'>
            <title>Other environments</title>
            <para>But what about other environments. What about a typical open source projects like Gradle or
                environments which consists of a single multi-project build . They don't integrate with other projects
                in the same environment or need to share dependency information in this environment. In such a (very
                common) case we think dependency management based on remote repositories is an unnecessary indirection
                which makes things more complicated than necessary. Gradle itself (which is build by Gradle) stores its
                dependencies in svn. There is a lib folder which contains all jars needed to build Gradle. Yet we have a
                complete management of our dependencies. For Gradle the lib folder is a local repository containing all
                the jars (in a flat structure). There are no xml descriptors. We use either client module dependencies
                to express our dependency relations, or artifact dependencies in case a first level dependency has no
                transitive dependencies. People can check out Gradle from svn and have everything necessary to build it.
                The same applies to our source distribution.
            </para>
            <para>You might argue that such an approach works only for projects like Gradle, which is not used as a
                library but is simply a distribution. What about open source library projects (e.g. commons-httpclient)
                that need to upload themselves to the Maven2 repo together with a
                <literal>pom.xml</literal>
                file. As soon as the limitation mentioned in
                <xref linkend='sub:client_module_dependencies'/>
                has been overcome, your project can upload to such a repository without relying on XML descriptor files
                themselves.
            </para>
            <para>You could also have a mixed strategy. If your main concern is bad metadata in the pom.xml and maintaining
                custom XML descriptors,
                <emphasis>Client Modules</emphasis>
                offer an alternative. But you can of course still use Maven2 repo and your custom repository as a
                repository for
                <emphasis>jars only</emphasis>
                and still enjoy
                <emphasis>transitive</emphasis>
                dependency management. Or you can only provide client modules for pom's with bad metadata. For the
                jars and the correct pom's you still use the remote repository.
            </para>
        </section>
        <section id='sub:implicit_transitive_dependencies'>
            <title>Implicit transitive dependencies</title>
            <para>There is another way to deal with transitive dependencies
                <emphasis>without</emphasis>
                xml descriptor files. You can do this with Gradle, but we don't recommend it. We mention it for the sake
                of completeness and comparison with other build tools.
            </para>
            <programlisting><![CDATA[
List groovy = ["org.codehaus.groovy:groovy-all:1.5.4:jar",
               "commons-cli:commons-cli:1.0:jar",
               "org.apache.ant:ant:1.7.0:jar"]
List hibernate = [...] // enter the dependencies here
dependencies {
	compile groovy
	runtime hibernate
}
]]></programlisting>
            <para>The trick is to use only artifact dependencies and group them in lists. That way you have somehow
                expressed, what are your first level dependencies and what are transitive dependencies.
            </para>
            <para>But for the Gradle dependency management all dependencies are considered first level dependencies. The
                dependency reports don't show your real dependency graph and the
                <literal>compile</literal>
                task uses all dependencies, not just the first level dependencies. All in all, your build is less
                maintainable and reliable than it could be when using client modules. And you don't gain anything.
            </para>
        </section>
    </section>
    <section id='sec:repositories'>
        <title>Repositories and Resolvers</title>
        <section id='sub:introduction'>
            <title>Introduction</title>
            <para>Gradle (Ivy) distinguishes between
                <emphasis>resolvers</emphasis>
                and <emphasis>repositories</emphasis>. A repository is the physical source for your dependencies. A
                resolver is responsible for retrieving a dependency (usually from a repository but not necessarily). As
                a Gradle or Ivy user,
                <emphasis>resolvers</emphasis>
                are the objects your are working with. You can also aggregate multiple resolvers in a certain order (not
                just linked lists). It is one of the very strengths of Ivy, how versatile you can aggregate resolvers
                and that you can write easily your <emphasis>own</emphasis>. Gradle for example makes use of this to
                implement client modules. If you add a resolver, you always have to give it a name. This name is used to
                internally address a resolver but is also used for the dependency logging. The Java plugin does not add
                any default resolver to your projects dependency manager. Gradle offers a couple of convenience methods
                to add resolvers. You can also always add an instance of an Ivy resolver object directly.
            </para>
        </section>
        <section id='sub:maven_repo'>
            <title>Maven Repository</title>
            <para>To add a resolver for the Maven2 repository (<ulink url='http://repo1.maven.org/maven2'/>) simply
                type:
            </para>
            <programlisting><![CDATA[
dependencies {
	addMavenRepo()
}
]]></programlisting>
            <para>The added resolver has the name
                <literal>MavenRepo</literal>
                and is added to the
                <literal>classpathResolvers</literal>
                (see <xref linkend='sub:resolver_container'/>).
            </para>
            <para>If you want to add a custom repository with a Maven layout you can type:
            </para>
            <programlisting><![CDATA[
dependencies {
	addMavenStyleRepo('myrepo', 'http://repo.gradle.org')
}
]]></programlisting>
            <para>Quite often certain jars are not in the official Maven repository for licensing reasons (e.g. JTA).
                But the poms are there and you want to use them. Gradle (and Ivy) use the same resolver to look for the
                pom and the corresponding artifact. It is now possible to define a chain of resolvers, where one
                resolver is used for retrieving the pom and another resolver is used for retrieving the artifact. For
                the dependencies of the artifact the chain of resolvers can be used. To solve this problem
            </para>
            <programlisting><![CDATA[
dependencies {
	addMavenRepo('http://repo.gradle.org', 'http://repo2.gradle.org')
}
]]></programlisting>
            <para>Now Gradle looks only in the official Maven repository for the poms, but looks in both the official
                Maven repository and the two repositories specified above for the artifacts belonging to the pom. Let's
                look at an example to understand this better.
            </para>
            <programlisting><![CDATA[
<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>repotest</groupId>
    <artifactId>repotest</artifactId>
    <version>1.0</version>
    <dependencies>
        <dependency>
            <artifactId>testdep</artifactId>
            <groupId>testdep</groupId>
            <version>1.0</version>
        </dependency>
    </dependencies>
</project>
]]></programlisting>
            <para>We have 4 files in different repositories. For this example let's assume that
                <literal>repotest-1.0.pom</literal>
                is in the official Maven repository and that the other files are in <literal>http://repo.gradle.org</literal>.
            </para>
            <para>Let's define our resolvers like this:
            </para>
            <programlisting><![CDATA[
dependencies {  
    addMavenRepo() 
	addMavenStyleRepo('myrepo', 'http://repo.gradle.org')
	compile "repotest:repotest:1.0"	
}
]]></programlisting>
            <para>Gradle finds
                <literal>repotest-1.0.pom</literal>
                in the official Maven repo. After this it tries to find the corresponding artifact <literal>
                    repotest-1.0.jar</literal>. It looks only in the Maven repo for this file as it expects to find pom
                and artifact by the same resolver. The build fails.
            </para>
            <para>Let's try to improve this:
            </para>
            <programlisting><![CDATA[
dependencies {  
    addMavenRepo('http://repo.gradle.org') 
	compile "repotest:repotest:1.0"	
}
]]></programlisting>
            <para>Gradle finds
                <literal>repotest-1.0.pom</literal>
                in the Maven repo. After this it tries to find the corresponding artifact
                <literal>repotest-1.0.jar</literal>
                and finds it in <literal>http://repo.gradle.org</literal>. But what about <literal>testdep-1.0.pom</literal>?
                As Gradle looks for poms only in the Maven repo it can't find this pom file.
                <footnote>
                    <para>To make things more flexible (or complicated): By default the build would not fail, as Ivy's
                        default behavior is to create internally a default pom if it can't find a pom. This default pom
                        has of course no dependencies and defines just the artifact
                        <literal>testdep-1.0.jar</literal>
                        and would be found in <literal>http://repo.gradle.org</literal>. If you want the build to fail if
                        a pom can't be found you must the set the
                        <literal>allownomd</literal>
                        property of the resolver to <literal>false</literal>.
                    </para>
                </footnote>
            </para>
            <para>The final correct version to solve our use case is:
            </para>
            <programlisting><![CDATA[
dependencies {  
    addMavenRepo('http://repo.gradle.org') 
    addMavenStyleRepo('myrepo', 'http://repo.gradle.org') 
	compile "repotest:repotest:1.0"	
}
]]></programlisting>
        </section>
        <section id='sub:flat_dir_resolver'>
            <title>Flat Directory Resolver</title>
            <para>If you want to use a (flat) filesytem directory as a repository, simply type:
            </para>
            <programlisting><![CDATA[
dependencies {
	addFlatDirResolver('lib', "$rootDir/lib1", new File(rootDir, 'lib2'))
	dependencies(':junit:4.4', ':commons-io:1.3.1:jar')
}
]]></programlisting>
            <para>In the example we assign multiple directories to a flat directory resolver
                <footnote>
                    <para>You can pass any type for describing a path, as long as the type's toString() method returns a
                        valid path.
                    </para>
                </footnote>
                . The first argument is the name of the resolver. The group attributes in the dependency declaration is
                empty (but there has to be a colon at the beginning). Specifying the extension (e.g. jar) is optional
                and defaults to jar. You could add a group attribute if you are in a chain of resolvers. This resolver
                simply ignores it. The repositories could look like this:
            </para>
            <programlisting><![CDATA[
project-root
  - lib1
    - junit-4.4.jar
  - lib2
    - commons-io-1.3.1.jar
]]></programlisting>
            <para>The
                <literal>addFlatDirResolver</literal>
                methods adds a resolver to the
                <literal>classpathResolvers</literal>
                (see <xref linkend='sub:resolver_container'/>)
            </para>
            <para>You can add easily file system repositories with a different layout (see <xref
                    linkend='sub:more_about_ivy_resolvers'/>)
            </para>
        </section>
        <section id='sub:cache'>
            <title>Cache</title>
            <para>When Gradle downloads dependencies from remote repositories it stores them in a local cache located at
                <literal>USER_HOME/.gradle/cache</literal>. When Gradle downloads dependencies from one of its
                predefined local resolvers (e.g. Flat Directory resolver), the cache is not used as an intermediate
                storage for dependencies.
            </para>
        </section>
        <section id='sub:resolver_container'>
            <title>Resolver Container</title>
            <para>There are three hooks for adding resolvers. Via the resolvers assigned to the
                <literal>classpathResolvers</literal>
                property of the dependency manager, the <literal>compile</literal>,
                <literal>compileTests</literal>
                and
                <literal>test</literal>
                tasks retrieve their dependencies. The
                <literal>uploadLibs</literal>
                and
                <literal>uploadDists</literal>
                tasks have both an
                <literal>uploadResolvers</literal>
                property. You can assign one resolver to multiple hooks.
            </para>
            <para>All of those hooks are instances of <apilink class="org.gradle.api.artifacts.ResolverContainer"/>.
                This class provided methods for adding new resolvers at a particular position in the resolve chain.
                <footnote>
                    <para>Ivy power users can set <literal>dependencies.chainConfigurer = { // some statements }</literal>.
                        This closure is applied to the <literal>ChainResolver</literal> containing the other Ivy resolvers.
                    </para>
                </footnote>
                Ivy offers more complex structures for resolvers than simple chains. The resolver container does not
                offer particular support for this. But by manipulating its properties directly you could set up such
                other structures.
            </para>
        </section>
        <section id='sub:more_about_ivy_resolvers'>
            <title>More about Ivy resolvers</title>
            <para>Gradle, thanks to Ivy under its hood, is extremely flexible regarding repositories:
            </para>
            <itemizedlist>
                <listitem>
                    <para>There are many options for the protocol to communicate with the repository (e.g. filesystem,
                        http, ssh, ...)
                    </para>
                </listitem>
                <listitem>
                    <para>Each repository can have its own layout.
                    </para>
                </listitem>
            </itemizedlist>
            <para>If you declare a dependency like
                <literal>junit:junit:3.8.2</literal>
                how does Gradle find it in the repositories. Somehow the dependency information has to be mapped to a
                path. In contrast to Maven, where this path is fixed, with Gradle you can define a pattern how this path
                should look like. Here are some examples:
                <footnote>
                    <para>At
                        <ulink url='http://ant.apache.org/ivy/history/latest-milestone/concept.html'/>
                        you can learn more about ivy patterns.
                    </para>
                </footnote>
            </para>
            <programlisting><![CDATA[
// Maven2 layout (if a repository is marked as Maven2 compatible, the organization (group) is split into subfolders according to the dots.)
someroot/[organisation]/[module]/[revision]/[module]-[revision].[ext]

// Typical layout for an ivy repository (the organization is not split into subfolder)
someroot/[organisation]/[module]/[revision]/[type]s/[artifact].[ext]

// Simple layout (the organization is not used, no nested folders.)
someroot/[artifact]-[revision].[ext]
]]></programlisting>
            <para>To add any kind of repository (you can pretty easy write your own ones) you can do:
            </para>
            <programlisting><![CDATA[
dependencies {
	classpathResolvers.add(new WebdavResolver()) {
	        name = 'gradleReleases'
	        user = codehausUserName
	        userPassword = codehausUserPassword
	        addArtifactPattern(root + "[artifact]-[revision].[ext]")
}
]]></programlisting>
            <para>
                <literal>WebdavResolver</literal>
                is a class that implements an Ivy interface and is part of the
                <emphasis>Gradle</emphasis>
                distribution. An overview of which Resolvers are offered by Ivy and thus also by Gradle can be found
                <ulink url='http://ant.apache.org/ivy/latest-milestone/configuration/resolvers.html'>here</ulink>. With
                Gradle you just don't configure them via xml but directly via their API.
            </para>
        </section>
    </section>
</chapter>
